캄퓨터 시스템의 구조

	내부장치 : CPU, 메모리
	외부장치(입출력장치) : 디스크,키보드,마우스,모니터,네트워크장치
	
	외부장치에서 내부장치로 데이터 읽음 -> 연산,기능 수행 -> 외부장치로 보냄
		input						output
		ㄴ 이를 입출력이라 함	

	컨트롤러 :  하드웨어 장치에 존재하며 제어하는 일종의 작은 CPU


CPU 연산과 I/O 연산

	CPU연산 : 메인 CPU 담당
	I/O연산 : 입출력 컨트롤러
		ㄴ 동시에 연산 가능

	로컬버퍼 : 장치 컨트롤러가 장치에서 입출력되는 데이터를 임시로 저장하기 위해 가지고있는 작은 메모리
		ex) 디스크,키보드등 데이터를 읽어오는 경우 로컬버퍼에 데이터 임시로 저장 -> 컨트롤러가 장치에서 로컬버퍼로 저장해줌
	
	ex) B 프로그램 디스크에서 데이터 읽어오라는 명령 -> 디스크 컨트롤러가 물리적인 디스크에서 내용을 읽어 로컬버퍼에 저장
		-> 컨트롤러가 인터럽트를 발생시켜 CPU에 보고 

		cf) cPU옆에는 인터럽트라인이 있음 -> CPU가 명령 하나를 수행할 때마다 인터러트 여부 파악 -> 미발생시 다음 명령 수행
										-> 발생시 다음 명령을 보류하고 인터럽트 처리
		

인터럽트의 일반적 기능

	인터럽트 처리 루틴 : 운영체제 커널에 인터럽트 발생 시 장치별 수행할 일을 저장해 놓은 루틴

	ex) 디스크 컨트롤러 인터럽트 발생 -> CPU가 해당 인터럽트 처리 루틴을 찾음 
		-> CPU가 디스크의 로컬버퍼 내용을 사용자 프로그램 메모리에 전달-> 프로그램이 CPU를 받아 다음 명령을 수행할 수 있음 표시

	하드웨어 인터럽트 : 컨트롤러 등 하드웨어 장치가 인터럽트 라인 세팅
	소프트웨어 인터럽트(=trap) :소프트웨어가 컨트롤러 역할을 함
		 ->CPU 서비스를 받는 방법은 둘다 동일함(CPU옆에 붙어 있는 인터럽트 라인에 신호를 줘서)

	인터럽트 벡터 : 인터럽트 종류마다 번호를 정해 /처리해야할 코드/가 위치하는 부분을 가르키는 자료구조
							ㄴ 인터럽트 처리 루틴(interrupt service routine), 인터럽트 핸들러

	cf) 인터럽트 처리 후 원래 작업하던 일을 계속 수행하기 위해 수행 중이던 작업을 저장하기 위한 장소를 운영체제가 별도로 가지고있음
	
	Trap(소프트웨어 인터럽트) : 사용자 프로세스로부터 CPU의 제어권을 운영체제에 이양되어 처리 ex) 예외상황(exception), System call
		예외상황 : 비정상적인 작업(0으로 나누기) , 배정 받은 메모리 영역을 바깥으로 접근, 권한 없는 작업 시도
		시스템 콜 : 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을때 운영체제 서비스를 요청하는 것
			ex) 사용자 프로그램에는 정의되지 않고 운영체제 커널에 있는 코드를 실행하려 할때 인터럽트 라인 세팅을 통해
											CPU제어권을 운영체제로 넘겨 실행
			ex) 어플 개발자가 키보드입력or 화면 출력 수행 할때 코드를 직접 작성하지 않고 커널의 코드 호출

인터럽트 핸들링 : 인터럽트가 발생한 경우에 처리 할 일의 절차를 의미함

	인터럽트 처리 전 CPU 상태 저장해야함
		CPU 상태 :  실행중인 명령의 메모리 주소 등 부가적인 정보를 의미
			CPU 명령이 실행 될때 CPU내부에 있는 임시 기억장치인 레지스터에 데이터를 읽거나 쓰면서 작업함
				-> 인터럽트 발생으로 새로운 명령을 실행하게 되면 기존의 레지스터를 지움
					-> 따라서 해당 레지스터의 정보(CPU 상태)를 PCB에 저장해야함

	PCB(Process Chain Block) : 운영체제가 현재 시스템 내에서 실행되는 프로그램을 관리하기 위한 자료구조
		각각의 프로그램마다 하나씩 존재하며 해당 프로그램의 실행 위치를 저장함
			-> 코드의 메모리 주소, 레지스터값, 하드웨어 상태등등 저장함

	현대의 운영체제 실행 조건 : 인터럽트가 발생했을 때만 운영체제가 실행됨
		CPU가 항상 사용자 프로그램에 의해 사용되고, 운영체제는 인터럽트가 발생했을 때만 CPU의 제어권을 획득함
			-> 인터럽트가 없다면 사용자 프로그램이 CPU를 계속 점유함

입출력 구조 : 입출력이란 컴퓨터 시스템이 컴퓨터 외부의 입출력 장치들과 데이터를 주고 받는것

	입출력 방식 : 동기식 입출력, 비동기식 입출력

	동기식 입출력: 프로그램이 입출력 요청시 해당 작업이 완료될때 까지 대기 후 후속작업을 진행함
		CPU 작업속도 보다 입출력 작업속도가 느림 -> CPU가 입출력 연산을 대기 할시 자원 낭비가 됨
		 -> 다른 프로그램(B)에 CPU를 할당해줌 -> 입출력 연산을 대기하는 프로그램은 봉쇄상태로 전환해 CPU를 할당하지 않음
		-> 입출력 연산 완료 통보를 인터럽트를 통해 수행 -> 운영체제 커널이 인터럽트 처리루틴으로 가서 봉쇄상태 해제
		-> 봉쇄상태가 해제 된 프로세스의 경우 다시 CPU 대기 줄을 섬 -> B 작업이 끝나고 입출력연산 이후의 작업을 수행함		
	
		동기성(Synchronization) 보장 : 장치별로 큐를 두어 요청한 순서를 두어 처리
			ex) A 프로그램이 디스크에 1인 파일 내용을 3으로 바꾸는 입출력 연산 요청 -> B프로그램에 CPU할당
				-> B프로그램 같은 파일 내용을 +1 입출력 연산 요청 
				원래 목적 : 1-3-4
				B프로그램의 입출력연산이 빠를경우 : 1-2-3
				이를 방지하기 위해 디스크에 큐를 두어 A가 요청한 입출력 연산 부터 처리
		
	비동기식 입출력: 프로그램이 입출력 연산을 요청후 결과를 기다리지 않고 CPU제어권을 연산을 요청한 프로그램에 다시 부여
		요청한 입출력 연산의 결과의 데이터와 상관없이 수행할 수 있는 경우, 
		하지만 입출력 연산의 결과 데이터가 필요한 경우 입출력이 완료된 후에 수행
			ex) 데이터를 읽을 필요없고 쓰는경우

	cf) 운영체제에서는 주로 동기식 입출력 사용	

DMA(Direct Memory Access) : CPU 이외에 메모리 접근이 가능한 장치		
	원칙적으로 CPU 의외의 장치가 메모리에 접근하기 위해서는 컨트롤러가 인터럽트를 통해 이루어져야 한다.
	해당 작업 이후 CPU가 로컬버파와 메모리 사이에서 데이터를 옮겨 주지만, 모든 메모리 접근 연산이 CPU에 의해서만 이루어지면 CPU의 처리능력 떨어져 DMA라는 일종의 컨트롤러가 있다

	DMA는 CPU가 자주 인터러브 당하는 것을 막아주며 로커버퍼에서 메모리로 읽어오는 작업을 대행해준다.
	이때 DMA는 byte단위가 아니라 블록이라는 큰 단위로 정보를 메모리에 읽어 CPU에 인터럽트를 발생시켜 작업완료를 알림


저장장치의 구조 : 주기억장치, 보조기억장치

	주기억장치: 주로 메모리라 지칭하며 전원이 나가면 내용이 사라지는 휘발성(volatile)으로 RAM을 매체로 대부분 사용함
	보조기억장치: 전원이 나가도 내용이 사라지지않는 비휘발성(novolatile)으로 마그네틱 디스크를 주로 사용
		2가지 용도
		파일시스템용: 유지할 정보를 파일형태로 저장
		스왑영역용: 메모리의 연장공간이며 하드디스크가 널리 사용됨
			->메모리와 동일하게 프로그램이 종료될때 내용을 삭제함

	스왑아웃(swap out):
		메모리는 용량이 작고 비싸며 다수의 프로그램을 동시에 올라가기 때문에 메모리 부족 현상이 자주 발생
		-> 이를 해결하기위해 운영체제가 프로그램 수행에 당장 필요한 부분만 메모리에 올리고 그렇지 않은 부분은 스왑영역에 내림

	하드디스크 구성 : 여러개의 마그네틱 원판(파일을 저장하는곳), 암이 회전하는 원판의 데이터를 읽고 씀
			원판의 표면은 트랙으로 나뉘며, 나눈 영역을 섹터라 함 
			섹터에는 최소한의 단위 정보가 저장됨

저장장치의 계층 구조: 
	빠른 저장장치                                                        //  느린 저장장치
	레지스터(CPU내부에 존재)->캐시 메모리 -> 메인 메모리 // -> 마그네틱 디스크 -> 광디스크 -> 마그네틱 테이프
		ㄴ 휘발성 			              	ㄴ 비휘발성

	캐싱기법 : 상대적으로 용량이 작은 빠른 저장장치를 이용해 느린 저장장치의 성능을 향상시키는 총체적 기법
		느린저장장치에 있는 내용중 당장 사용되거나, 빈번히 사용되는 정보를 빠른 저장장치에 저장	
			-> 두 저장장치의 사이의 속도를 완충시킴
			-> 적은 용량의 캐시메모리를 사용해서 메인 메모리 같이 큰 용량을 가진것처럼 효율적으로 동작함
			-> 다양한 저장장치 계층에서 활용함으로써 적은 용량의 상위 저장장치만으로 빠른 수행속동의 성능을 얻음

하드웨어의 보안: 다중 프로그래밍 환경에서 프로그램간 실행이 방해되거나 충동을 막기위해 2가지 모드 지원
	커널 모드: 운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행하는 모드
			-> 시스템에 중요한 영향을 미치는 연산을 커널모드에서 함으로써 하드웨어의 보안 유지(ex개인정보)
	사용자 모드: 일반 사용자의 프로그램이 실행될때 제한적인 명령만 실행

	모드비트: 사용자 모드 코드에서 커널 모드에서 수행하는 연산을 작성하여 사용하지 못하게 감시하는 역할, 모드 비트가 0일때만 특권명령 수행가능
		-> 컴퓨터 시스템에서 CPU내부에 모드 비트를 0을 둘때만 커널모드로써 모든 명령 수행 가능
		-> CPU는 보안 관련 명령 수행전 항상 모드비트를 조사 -> 0이면 수행
		-> 운영체제가 CPU 제어권을 사용자 프로그램에 넘길때 모드비트를 1로 세팅함
		-> 사용자 프로그램에서 보안이 필요한 명령(=특권명령) 수행시 시스템 콜을 통해 운영체제가 대신하게 요청함
				-> 인트럽트 발생시 모드비트를 0으로 바꿈 (운영체제가 CPU제어권을 갖는 경우는 인터럽트 밖에 없음)

	입출력 명령 : 다른 소유자의 파일에 접근할 수 있음으로 특권명령으로 규정
			-> 사용자 프로그램에서 입출력을 원하면 시스템콜로 운영체제 요청해야 함
			-> 운영체제는 올바른 요청인지 확인함으로써 보안을 유지함

메모리 보안 : 사용자 프로그램이 다른 프로그램이나 운영체제가 위치한 메모리 영역을 침범할 수 있음을 방지해야함
						ㄴ 인터럽트벡터, 인터럽트 처리루틴에 접근하면 특권명령의 보안성을 침해함
		-> 기준레지스터(base register), 한계레지스터(limit register) -> 2개의 레지스터로 접근하는 메모리 주소값이 합법적인지 확인
	기준레지스터 : 수행되는 프로그램이 접근할 수 있는 메모리상의 주소중 가장 작은 값
	한계레지스터 : 프로그램이 기준레지스터값 부터 접근할 수 있는 범위 값
		-> 기준레지스터 ~ 기준레지스터+ 한계레지스터 사이의 주소 영역에만 접근 가능
		-> 사용자 프로그램이 접근하려는 주소가 불법적 범위면 예외상황을 발생시켜 CPU의 제어권을 운영체제로 이양후 강제 종료

	-> 해당 보안 방법은 프로그램 메모리 영역이 단순하게 연속적으로 위치할때 사용되는 기법
	-> 메모리 접근연산 자체는 특권 명령이 아님 -> cpu 제어권을 가지고 연산을 수행하는것임으로
	-> 커널모드에서는 모든 메모리 접근 가능함, 기준,한계 레지스터 값을 세팅하는 연산은 특권명령임

CPU 보호 : 무한반복을 통해 CPU를 독점하는 경우 인터럽트로도 뺏을 수없기 때문에 타이머라는 하드웨어 사용
	타이머 : 일정 수행시간이 지나면 인터럽트가 발생돼 운영체제가 CPU제어권을 획득
 		매 클럭 틱 (clock tick) 마다 1씩 감소함 -> 시분할 시스템에서 현재시간을 계산하기 위해 사용되기도 함
	로드타이머(load timer) : 타이머 시간을 세팅 명령 -> 특권명령
	
시스템 콜을 이용한 입출력 수행 
	사용자 프로그램에서 입출력 연산을 운영체제에 서비스를 대행해 달라는 요청
	ex) 사용자 프로그램에서 디스크에 저장된 정보가 필요해 시스템 콜 발생시킴 -> 운영체제 CPU제어권 획득 
		-> 운영체제가 인터럽트 처리 루틴에 따라 디스크 컨트롤러에게 입출력 수행 요청 -> 컨트롤러가 수행 후 인터럽트 발생시킴
		-> 사용자 프로그램이 CPU 제어권 획득

// 23년 5월 25일 복습