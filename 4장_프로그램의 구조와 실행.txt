프로그램의 구조와 인터럽트
	모든 컴퓨터 프로그램의 내부 구조는 함수로 구성
	프로그램이 CPU에서 명령을 수행하려면 해당 명령을 담은 프로그램의 주소영역이 메모리에 올라가있어야함
	프로그램의 주소영역 : 코드(code),데이터(data),스택(stack) 영역으로 구분
		코드 영역:함수의 코드가 CPU에서 수행할 수 있게 기계어 명령(machine instruction) 형태로 저장된 부분
		데이터 영역: 프로그램이 사용하는 데이터를 저장하는 부분 ex) 전역변수
		스택 영역 : 호출된 함수의 수행을 마치고 복귀할 주소 밑 데이터를 임시로 저정하는 부분
			-> 함수가 호출되면 다음에 실행할 명령(instruction)의 메모리 위치가 바뀜 -> 복귀주소필요

	인터럽트의 동작원리 -> 함수의 호출과 비슷
		프로그램 A CPU를 할당받고 명령 수행 -> 인터럽트 발생 -> A의 현재 수행 명령위치 저장
		-> 인터럽트 처리루틴으로 넘어간 후 처리 ->저장한 지점 부터 다시 명령 수행
		cf) A의 수행 명령 위치는 운영체제가 프로세스 제어블록(PCB)에 저장함

컴퓨터 시스템의 작동 개요
	CPU는 매 시점 메모리의 특정 주소에 존재하라는 명령을 읽어와 실행됨 
	PC(program counter) : CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터 
		-> CPU는 PC가 가르키는 메모리 위치의 명령을 처리함
		-> PC가 운영체제의 메모리를 가르키고 있다면 CPU는 커널모드에서 수행 중
		-> PC가 사용자 프로그램의 메모리를 가르키고 있다면 CPU는 사용자 모드에서 수행중
 	cf) CPU는 PC에 따라 순차적으로 수행하나, 함수호출,반복문 등으로 메모리 위치를 점프해 그렇지않는경우도 존재

프로그램의 실행
	프로그램 실행 -> 2가지 의미
	1. 디스크에 존재했던 실행파일이 메모리에 적재됨
	2. 프로그램이 CPU를 할당 받고 명령을 수행 하고 있는 상태
	-> 실행파일을 한번에 메모리에 올리지 않고 필요한 부분만 올림 -> 나머지 부분은 스왑 영역에
	
	cf) 프로세스 :  현재 실행 중인 프로그램

	가상메모리,논리적 메모리 : 프로그램마다 독자적으로 존재하는 주소 공간
	
	운영체제의 커널 또한 코드,데이터, 스텍의 주소 공간 구성을 가짐
		커널의 코드 : CPU와메모리의 자원 관리/편리한 인터페이스를 제공을 위한 코드/ 
			      / 인터럽트, 시스템 콜 처리 코드
		커널의 데이터 : 자원을 관리하기 위한 자료구조가 저장됨
			ex)  PCB : 프로세스 상태, CPU 사용 정보, 메모리 사용 정보 등을 유지하기 위한 자료구조
		커널의 스텍 : 일반 프로그램의 스텍과 유사하게 복귀 주소를 저장하기 위한 용도
			일반 프로그램의 스텍과 다른점은 프로세스 마다 별도의 커널스택을 둠
			-> 프로세스가 일반명령의 함수 실행 자신의 스택에 복귀 장소 저장
			-> 프로세스가 특권명령의 함수 수행하려 시스템 콜 호출하고 해당 시스템 콜 내부에서
			    다른 함수를 호출하면 복귀주소는 커널의 주소가 됨으로 커널 스택에 저장
		유의) 시스템 콜, 인터럽트로 CPU의 수행 주체가 운영체제로 바뀌게 되면 복귀 정보를
		        스택이 아닌 PCB에 저장함
		        -> 커널 또한 함수 구조이기 때문에 커널 코드에서 함수 호출은
			시스템콜, 인터럽트를 발생시킨 프로세스의 커널 스택을 사용

사용자 프로그램이 사용하는 함수
			┌ 프로그래머 본인이 작성한 함수	
	크게 3가지 -> 사용자 정의함수, 라이브러리 함수, 커널함수
					ㄴ 누군가 작성해놓은 함수
		사용자 정의함수,라이브러리 함수 -> 프로그램의 코드 영역에 기계어 형태로 존재 
				->프로그램 실행 시 해당 프로세스의 주소공간에 포함되며 함수 호출 시 자신의 주소공간의 스텍을 사용
		커널함수 : 운영체제 커널 코드에 정의된 함수
			커널함수 종류 : 운영체제 서비스를 요청을 위한 시스템 콜, CPU 서비스 요청을 위한 인터럽트처리함수
					-> 운영체제 커널의 주소공간에 코드가 정의됨
			-> 사용자 프로그램이 운영체제에 있는 함수를 호출하는 것(printf(), read(), write())

인터럽트
	CPU는 단순하게 PC가 가르키는 곳에 있는 명령을 수행하기 때문에 CPU를 회수해서 다른 일을 수행하기 위해서는 인터럽트 매커니즘 필요
	->PC가 가르키는 지점의 명령을 수행 후 다음 명령 수행 전에 인터럽트라인이 세팅 되었는지 체크
	-> 인터럽트 발생 시 수행하던 프로세스를 멈추고 운영체제의 인터럽트 처리루틴으로 이동해 인터럽트 처리
	-> 이후 인터럽트 발생 직전의 프로세스에 CPU의 제어권이 넘어감

	인터럽트 처리중 다른 인터럽트 발생 경우
	-> 원칙적으로는 데이터의 일관성을 유지하기 위해 해당 경우를 허용하지 않음
	-> 예외의 경우는 허용 : 중요도가 높은 인터럽트가 들어왔을 시
		예외 경우 : 현재 인터럽트보다 중요도가 높은 인터럽트 발생 -> 현재 처리 중이던 인터럽트 코드의 수행지점 저장
			   -> 우선순위 높은 인터럽트 처리 -> 저장된 주소로 복귀해 우선순위 낮은 인터럽트 처리

시스템 콜
	프로그램의 독자적인 주소 공간에서의 함수 호출이 아닌 다른 주소(커널) 공간의 함수를 호출하는 것
		일반 함수 호출 : 프로그램 본인의 스택에 복귀 주소를 저장한 후 호출된 함수 주소로 이동
		시스템콜 : 프로그램이 인터럽트 라인에 인터럽트 세팅 명령을 함(일반적인 인터럽트 발생과 동일함)
	ex) 디스크 파일 입출력
		사용자 프로그램(A)이 CPU에서 명령 수행 중 디스크 파일을 읽기 위해 시스템 콜로 커널 함수 호출 
		-> CPU의 제어권 운영체제에 이양됨(인터럽트 라인 세팅명령을 통해) ->운영체제는 설정된 인터럽트라인을 통해 입출력 요청을 인지
		-> 서비스 루틴으로 이동해 CPU는 디스크 컨트롤러에게 파일을 읽어오라 명령 
		-> 입출력명령은 오래 걸리고 해당 명령을 요쳥한 프로세스는 파일 데이터가 없기 때문에 CPU제어권을 다른 프로세스(B)에 이양
		-> 입출력 완료시 디스크 컨트롤러가 하드웨어 인터럽트를 발생 시켜 작업이 완료됨을 알림 
		-> B작업 멈추고 인터럽트 처리 루틴으로 CPU 제어권 이양									
				ㄴ 디스크로부터 로컬버퍼로 읽어온 내용을 컴퓨터 내의 메모리로 복사후 디스크 입출력을 요청했던 A가 CPU를 획득할 수 있는 권한을 줌 
		-> A 프로그램이 CPU를 기다리는 큐에 삽입 -> B프로그램 다시 수행

프로세스의 두가지 실행 상태
	사용자 모드에서 실행 상태 (user mode running) : 사용자 정의 함수, 라이브러리 함수등 자신의 공간에서 정의된 코드를 실행하는 상태 
	커널 모드에서 실행 상태(kernel mode running) : 커널의 시스템 콜 함수를 실행하는 상태
		cf) 시스템 콜에 의해 프로그램 A가 운영체제에게 CPU 제어권을 뺏겻더라도 커널 코드가 실행하는 건 프로그램 A가 해야 할일을 대행하는 것임으로 A를 실행상태로 간주
		cf) 프로그램의 실행이 끝날 때는 커널모드로 진입해 프로그램을 종료함