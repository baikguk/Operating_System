프로세스의 개념
	프로세스(=job) : 실행중인 프로그램
	프로세스의 문맥(context) : 프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위한 정보
				ex) 프로세스의 주소공간(코드,데이터,스택 상태), 레지스터의 값,시스템콜을 통해 커널에서 수행한일의 상태,
				     커널이 관리하고 있는 정보등등
		여러 프로세스와 수행되는 시분할 시스템 환경에서는 타이머 인터럽트로 각각의 프로세스 짧은 시간동안 CPU제어권을 소유하기 때문에
		CPU를 다시 얻었을 때 이전 수행 시점의 정확한 상태를 재현해야함. 이때 재현에 필요한 정보가 프로세스의 문맥임
	context 구성 크게 3가지 -> 하드웨어문맥, 프로세스 주소공간, 커널상의 문맥
		하드웨어 문맥 : CPU의 수행상태(프로그램 카운터값,레지스터에 저장된값)
		프로세스 주소공간: 각각의 프로세스가 독자적인 주소공간을 가지고 있음
		커널상의 문맥 : 운영체제가 프로세스를 관리하기 위한 자료구조인 PCB와 커널스택

							프로세스 종료
						┌ㅡㅡㅡㅡㅡㅡㅡ>ㅡㅡㅡㅡㅡㅡ>┐
프로세스의 상태 : 시작(new), -> 준비(ready) ↔ 실행(running) -> 봉쇄(blocked,wait,sleep), 종료(terminate)			
				└------<--------------<-----┘
				      입출력등 작업완료
	시작 : 프로세스가 시작되고 수행을 위한 각종 자료구조는 생성되었지만 메모리 획득을 승인 받지 못한 상태
	준비 : 프로세스가 CPU를 받으면 바로 실행할 수 있지만 할당받지 못한 상태
	실행 : 프로세스가 CPU를 보유하고 기계어 명령을 실행하고 있는 상태
	봉쇄 : 프로세스가 CPU를 할당받더라도 명령을 실행할 수 없는 상태
	종료 : 프로세스가 종료되었으나 해당 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태

	문맥교환 : 실행시킬 프로세스를 변경하기 위해 A프로세스의문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정
			->입출력 인터럽트를 받아 봉쇄상태인 경우도 같이 해당됨

	CPU 디스패치(dispatch) : 준비 상태인 프로세스가 간택당해 실제로 CPU제어권을 넘겨받는 과정	

	ex1) 타이머 인터럽트를 받는 경우
		A프로세스 실행 -> 타이머 인터럽트 
		-> CPU 운영체제에 이양 , 타이머 인터럽트 처리루틴으로 이동 A프로세스의 문맥 저장 및 준비 상태 프로세스중 다음 실행될 프로세스 선택
		-> A프로세스 준비상태로 -> 선택된 프로세스 실행상태로

	ex2) 입출력 인터럽트를 받는 경우
		A프로세스 실행 -> 시스템 콜 -> A프로세스 봉쇄상태 -> B프로세스와 문맥교환 -> B프로세스 실행----------------------------------------------------------------------------------------------------
						ㄴ한편, A프로세스는 디스크 입출력 큐에서 대기 -> 디스크 컨트롤러 부터 서비스를 받음 -> 디스크 컨트롤러가 수행완료 인터럽트발생----------------
		===============================================================================================
		-> CPU B프로세스에서 운영체제로 이양 -> B프로세스 커널 모드 실행 상태 -> 디스크 인터럽트 처리(운영체제가 A프로세스 상태를 준비로 바꾸고 로컬버퍼에 있는 내용 메모리로 이동 )
		------------------------------------------┘ 	ㄴB프로세스 입장에서 본인과 무관한 인터럽트지만 편의상 B에서 실행하는걸로 간주
		==================================================================================================
		-> 디스크 인터럽트 처리가 끝난 후 CPU 소유는 CPU 스케쥴러에 따라 달라짐

프로세스의 제어블록(PCB) : 운영체제가 시스템내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조
	프로세스의 상태 : CPU를 할당해도 되는지에 대한 여부를 결정하기 위한 정보 -운영체제가 관리
	프로그램 카운터의 값 : 다음에 수행할 명령의 위치 - 운영체제가 관리
	CPU 레지스터의 값 : CPU 연산을 위해 현 시점의 레지스터에 어떤 값을 저장하는지- cpu 수행 관련 하드웨어 값
	CPU 스케쥴링 정보 : 프로세스의 CPU 스케쥴링을 위한정보 - 운영체제가 관리
	메모리 관리 정보 : 프로세스의 메모리 할당을 위한 정보 - 메모리 관련
	자원 사용 정보 : 사용자에게 자원 사용 요금을 계산해 청구하는 용도
	입출력 상태 정보 : 프로세스가 열람한 파일 정보 등 입출력 관련 상태 정보 - 파일 관련

문맥교환 : 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정	
	cf) 타이머 인터럽트로 실행되는 프로세스가 바뀌거나, 입출력 요청 시스템 콜로 인해 봉쇄상태에 들어가는 경우 문맥교환이 발생하지만, 
		그 외의 인터럽트나 시스템콜은 문맥교환이 일어나지 않고 실행 모드만 사용자모드에서 커널모드로 바뀔 뿐이다(->너무 많은 오버헤드(Overhead)가 발생하지 않도록)
	
	오버헤드 : 어떤 처리를 하기위해 간접적으로 들어가는 추가적인 시간
	cf) 타이머 시간이 너무 짧으면 과도한 오버헤드 발생, 타이머 시간이 너무 길면 시분할 시스템의 의미가 퇴색 -> 적절한 타이머(CPU 할당시간) 필요

프로세스를 스케줄링하기 위한 큐 : 
	준비 큐 : 운영체제가 준비 상태의 프로세스를 줄을 세워 순서를 기다리게 함 -> 줄을 서는 방법은 CPU 스케쥴링에 따라 다름
	장치 큐 : 운영체제가 봉쇄 상태의 프로세스를 줄을 세워 순서를 기다리게 함
		하드웨어 자원 : 특정 자원을 기다리는 프로세스 대기 줄 ex) 디스크 입출력 큐 ,키보드 입출력 큐, 화면이나 프린터에 처리 결과 입출력 큐 
			ex) 디스크 입출력 완료 -> 디스크 컨트롤러 CPU에 인터럽트 발생 -> 인터럽트 처리루틴에 의해 입출력 완료된 프로세스 입츌력 큐에서 준비큐에 들어감
		소프트웨어 자원 :  공유데이터
			-> 접근 중인 프로세스가 다 사용하고 반납할 때까지는 다른 프로세스가 CPU를 할당 받았더라도 접근 못함	
				-> 데이터의 일관성을 위해 -> 큐를 통해 공유데이터가 필요한 프로세스들이 줄을 서게해 일관성을 유지

	작업 큐 : 운영체제가 시스템내에 있는 모든 프로세스가 작업 큐에 속함(프로세스의 상태와 무관하게)
			-> 준비큐, 장치 큐에 있는 프로세스들은 모두 작업큐에 속함

	큐 : 큐는 각 프로세스의 PCB를 연결 리스트 형태로 관리하며 포인터로 순서를 정함		

스케쥴러 
	어떤 프로세스에 CPU를 할당할지에 대한 운영체제 커널의 코드

	장기 스케쥴러(=작업 스케쥴라) : 준비 큐에 어떤 프로세스를 진입시킬지 결정 -> 시작상태의 프로세스에게 메모리 할당하는 문제에 관여됨
				     수십초~ 수 분단위로 호출됨 -> 수행속도 느려도 됨
				     메모리에 동시에 올라가 있는 프로세스의 수(degree of mulitprogramming)를 결정함
				     현대의 시분할 시스템에서는 메모리의 여유로 인해 프로세스가 시작상태가 되면 장기 스케쥴러을 사용하지않고 곧바로 메모리를 할당해 준비 큐에 넣음

	중기 스케쥴러 : 현대의 시분할 시스템에서는 장기 스케쥴러 대신 사용됨
		        너무 많은 프로세스에게 메모리를 할당해 시스템의 성능 저하를 해결하기 위해 프로세스의 수를 동적으로 조절해줌
				->CPU 수행에 필요한 프로세스의 주소공간조차 메모리에 올리기 힘들어짐 -> 디스크 입출력이 수시로 발생해 성능 저하
		        스왑 아웃 (swap out) : 위 상황의 경우 프로세스 일부를 선정해 메모리를 통째로 빼앗아 디스크의 스왑내용에 저장함	
				-> 선정하는 프로세스의 0순위는 봉쇄 상태인것들 그래도 메모리가 부족하면 1순위로 타이머 인터럽트가 발생해 준비 큐로 이동하는 프로세스를 스왑아웃
		       	-> 메모리에 동시에 올라와있는 프로세스의 수를 조절한다는 점에서는 장기 스케쥴러와 유사
		        중지 상태 : 스왑아웃 된 프로세스의 상태를 나타내기 위해 중지(suspended,stopped) 라는 상태가 추가됨 ->일말의 메모리도 얻지 않음
			중지 준비상태(suspended ready) : 준비 상태의 프로세스가 스왑아웃이 되면 얻는 상태
			중지 봉쇄상태(suspended block) : 봉쇄 상태의 프로세스가 스왑아웃이 되면 얻는 상태 ->봉쇄의 조건이 만족되면 중지준비상태로 바꿈

	단기 스케쥴러(=CPU 스케쥴러) : 어떤 프로세스를 실행 상태로 할지 결정 ->준비상태의 프로세스에게 CPU를 할당해주는지에 대해 관여 
										-> 시분할 시스템에서는 타이머가 작동되면 단기 스케줄러 빈번하게 호출됨 -> 수행속도가 빨라야함


프로세스의 생성	책 131p ~ 138p -> 유닉스 예시 읽어보기
	최초의 프로세스는 운영체제가 직접 생성 -> 이후의 프로세스는 이미 존재하는 프로세스를 복제 생성 ->부모 프로세스가 자식 프로세스를 생성
	부모프로세스를 종료시키기 위해서는 생성한 모든 후손 프로세스를 종료해야함
	생성된 프로세스는 부모와 자원을 공유할 수도 있고, 운영체제가 직접 할당해 줄수도 있음
	부모와 자식 프로세스가 공존하며 수행되는 경우 CPU를 경쟁함
	부모가 자식이 수행될때 wait하는 모델의 경우 -> 부모 프로세스는 봉쇄상태로 기다리다 자식프로세스가 종료되면 준비 상태가 됨 -> 자식 부모간의 동기화(synchronization)
								ㄴ 일반적인 봉쇄상태 처럼 자원을 기다리는며 줄을 서는게 아니라 완전 수면상태임
	자식 프로세스가 복제 생성이 되었더라도 독자적인 주소공간을 갖음
		-> 처음 복제 될때는 프로세스 ID만 제외하고 모든게 동일하게 복제되지만 이후 exec() 시스템 콜로 새로운 프로그램으로 주소공간을 덮어씌울수 잇음
			ㄴ모든 문맥이 동일함, 수행한 명령의 시점 뿐 만아니라 지가 부모인지암 -> 그나마 구별하기 위해 fork()의 결과값으로 원본은 양수 복제본은 0을 줌
													ㄴ 프로세스 생성 명령어

	프로세스의 종료
		자발적 종료 : 프로세스가 모든 명령을 수행하고 코드 마지막에 exit() 시스템 콜을 통해 운영체제에 알림 -> exit() 컴파일러가 자동으로 프로세스 종료전에 삽입해줌
		비자발적 종료 : 부모 프로세스가 자식 프로세스를 강제 종료 시킴
			1. 자식 프로세스가 할당 자원의 한계치를 넘는 경우
			2. 자식 프로세스에게 할당된 작업이 더 이상 필요하지 않는경우
			3. 부모가 종료되는 경우
				cf) 서버는 24시간 잘 돌아가야되는데 관리자가 로그아웃을 통해 로그인을 부모로 하는 프로세스들이 종료될 상황
				서버에 로그인을 통해 만들어지는 프로세스가 있음 -> 로그아웃하게되면 부모 프로세스(로그인)이 종료됨으로 파생된 자식 프로세스가 종료됨
										-> 파생된 자식이 필요한경우 다른 부모에게 이양해 계속 수행하게 하는 경우도 잇음

	-> 프로세스 생성과 관련된 fork(), exec(),는 사용자 프로세스가 직접 수행할 수 없는 특권명령임

프로세스간의 협력
	원칙적으로 프로세스는 자신만의 독립적인 주소 공간을 가지고 수행됨, 부모 자식 관계이더라도 생성 후 자식은 자신만의 주소공간을 참조해 코드를 수행함
	경우에 따라서는 프로세스 끼리 처리결과나 정보를 공유하여 효율이 늘어날수도 있음 -> 서로 다른 프로세스들끼리 각자의 명령 수행에 영향을 미칠수 있음

	IPC(Inter-process Communication) : 하나의 컴퓨터 안에서 실행 중인 다른 프로세스간에 발생하는 통신 ->의사소통기능과 동기화 보장해야함-> 공유 데이터값을 변경하면 다른 프로세스 접근불가
		
		메시지 전달(message passing) : 메세지 통신을 하는 시스템은 시스템 커널에 의해 send(), receive 연산을 제공 받고 커뮤니케이션 링크를 생성함
									ㄴ 특권명령으로 통신을 원하는 프로세스만 가능하도록 
			직접통신 : 프로세스간 링크 자동생성, 프로세스에게 직접 메시지를 송수신함, 한쌍의 프로세스당 하나의 링크, 단방향 or 양방향 둘다 가능 
			간접통신  메일박스 or port를 통해 메시지 전달, 하나의 링크가 여러 프로세스에게 공유 가능, 단방향 or 양방향 둘다 가능
			
		공유메모리(shared memory) : 프로세스들이 시스템 콜을 통해 자신의 주소 공간 일부를 공유하여 통신함 -> 동기화의 경우 커널이 책임지지않아 프로세스들끼리 해결해야함

